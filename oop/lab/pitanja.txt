foo(double) i foo(int) -> proslijedis 'a'	OK	//isto i kad proslijedis true ili false
foo(double) i foo(char) -> proslijedis 97	NO

ili npr foo(int) i foo(char) a ja proslijedio krkanski broj 100000000000000000, kae ambiguous, zar nije logicnije malo da izgubi do inta

//zadnji testcase iz zadace, valjda treba swap ako je >= ("p" i "q") a on ih tamo ne dira
// kad sam obrno i reko da swapa za false ONDA RADI KAKO TREBA ZASTO HA

varijable deklarisane and/or inicijalizirane u namespaceu - globalne ili ne 

(OPTIONAL) string a{97,'c'} i string a(97,'c'), koji ce od ova dva pozivati koji konstruktor u klasi string


while(cin>>x) 
{
	vektor.push_back(x);
}
 - ja pritisno ctrl+D i sve ok bilo


while(bool(cin))
{
	cin>>x;
	vektor.push_back(x);
}
- ja pritisno ctrl+D i on mi dodo taj broj dva puta ?????


int a = 'a'; OK
char const& b = a; OK
++a;
a je sad 98 logy
b je ostalo 'a'
stavise, char& b = a; ne more, znam sto ne more al sto more s const


void foo(string b) - pozvao sam je kao foo("c") OK
			  - pozvao sam je kao foo('c') NO - zasto no kad se objekat tipa string moze konstruisati sa karakterom



string a = "sinisa" OK
string a = 's' NE
string a{'s'} OK
string a('s') NE

//imam vector<int> boris i ja njemu kazem auto x = inserter(boris,boris.begin()+3) i ovo mi da core dumped (jesam ukljucio sam <iterator>)
//SKONTALI SMO, PAZI NA ONO DA NAKON MIJENJANJA VELICINE NIZA PRETHODNI ITERATORI BUDU INVALID

Inicijalizacija nekih vrijednosti u template funkcijama, odnosno default argumenti (da li ce on tu zakljuciti tip ili ne)

template<class T>
void foo(T a = "abc")
{
	cout<<a;
}
foo(5);


de ti nama objasni ovaj extern, za sta je to i kad da ga koristimo??? test.hpp + testiramoExtern.cpp + testiramoExtern2.cpp









